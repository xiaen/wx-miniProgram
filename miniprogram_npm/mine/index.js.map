{"version":3,"sources":["mine.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\n// Mine a string for require calls and export the module names\n// Extract all require calls using a proper state-machine parser.\nmodule.exports = mine;\nfunction mine(js) {\n  js = \"\" + js;\n  var names = [];\n  var state = 0;\n  var ident;\n  var quote;\n  var name;\n  var start;\n\n  var isIdent = /[a-z0-9_.$]/i;\n  var isWhitespace = /[ \\r\\n\\t]/;\n\n  function $start(char) {\n    if (char === \"/\") {\n      return $slash;\n    }\n    if (char === \"'\" || char === '\"') {\n      quote = char;\n      return $string;\n    }\n    if (isIdent.test(char)) {\n      ident = char;\n      return $ident;\n    }\n    return $start;\n  }\n\n  function $ident(char) {\n    if (isIdent.test(char)) {\n      ident += char;\n      return $ident;\n    }\n    if (char === \"(\" && ident === \"require\") {\n      ident = undefined;\n      return $call;\n    } else {\n      if (isWhitespace.test(char)){\n        if (ident !== 'yield' && ident !== 'return'){\n          return $ident;\n        }\n      }\n    }\n    return $start(char);\n  }\n\n  function $call(char) {\n    if (isWhitespace.test(char)) return $call;\n    if (char === \"'\" || char === '\"') {\n      quote = char;\n      name = \"\";\n      start = i + 1;\n      return $name;\n    }\n    return $start(char);\n  }\n\n  function $name(char) {\n    if (char === quote) {\n      return $close;\n    }\n    if (char === \"\\\\\") {\n      return $nameEscape;\n    }\n    name += char;\n    return $name;\n  }\n\n  function $nameEscape(char) {\n    if (char === \"\\\\\") {\n      name += char;\n    } else {\n      name += JSON.parse('\"\\\\' + char + '\"');\n    }\n    return $name;\n  }\n\n  function $close(char) {\n    if (isWhitespace.test(char)) return $close;\n    if (char === \")\" || char === ',') {\n      names.push({\n        name: name,\n        offset: start\n      });\n    }\n    name = undefined;\n    return $start(char);\n  }\n\n  function $string(char) {\n    if (char === \"\\\\\") {\n      return $escape;\n    }\n    if (char === quote) {\n      return $start;\n    }\n    return $string;\n  }\n\n  function $escape() {\n    return $string;\n  }\n\n  function $slash(char) {\n    if (char === \"/\") return $lineComment;\n    if (char === \"*\") return $multilineComment;\n    return $start(char);\n  }\n\n  function $lineComment(char) {\n    if (char === \"\\r\" || char === \"\\n\") return $start;\n    return $lineComment;\n  }\n\n  function $multilineComment(char) {\n    if (char === \"*\") return $multilineEnding;\n    return $multilineComment;\n  }\n\n  function $multilineEnding(char) {\n    if (char === \"/\") return $start;\n    if (char === \"*\") return $multilineEnding;\n    return $multilineComment;\n  }\n\n  state = $start;\n  for (var i = 0, l = js.length; i < l; i++) {\n    state = state(js[i]);\n  }\n  return names;\n}\n"]}